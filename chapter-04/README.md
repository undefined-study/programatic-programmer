# 실용주의 편집증

_완벽한 소프트웨어는 만들 수 없다_

## 21. 계약에 의한 설계 (Design By Contract)

정직한 거래를 보장하기 위한 최선의 해법으로 계약을 한다. 계약은 상대편은
물론 자신의 권리의 책임을 정의하고, 한쪽이 계약을 어겼을 경우 손해에 대해
계약 사항에 포함된다.

정직한 거래를 위해 계약을 하듯, 정확한 프로그램을 위해 계약에 의한 설계가
필요하다. 스스로 자신이 하는 일이라고 주장하는 것보다 많거나, 적지도 않게
딱 그만큼만 하는 프로그램을 말한다.

정확한 프로그램을 위해 선행되어야 하는 조건이 있다. 정해진 역할을 하는 루틴을
호출하기 위해 참이어야 하는 조건들을 의미하며, 루틴의 선행조건들이 거짓일 경우
루틴은 호출되어서는 안된다. 

_여기서 루틴을 한 가지 특정 역할을 잘 수행하는 함수를 루틴으로 생각해보면..
확실히 루틴을 수행하기 위한 검증은 루틴(함수)에 담지 않고, 따로 관리해야되는
것인가 보다._

후행조건 또한 존재한다. 선행된 조건에 의해 호출된 루틴은 자기가 맞은 일에 대해
자기가 할 것이라고 보장되어야 한다. 루틴의 후행조건이 있다는 것은 곧 그것이 
종국에는 종료될 것이라는 것을 암시한다. 이때 무한 반복은 허용되지 않는다.

클래스 불변식, 호출자의 입장에서 볼 때는 이 조건이 언제나 참이라고 클래스가
보장해야 한다. 루틴이 호출 이후 내부에서 처리되고 있을 때 제어권이 반환되면,
이때 불변식이 참이어야 한다.

계약에 부응하지 못하는 게 버그가 되어버리는 실수를 하지 말자.

_계약에 따른 설계를 하라_

게으른 코드를 짜라. 자신이 수용할 것에 대해서는 엄격하게 제한하고, 내어줄 것에
대해서는 최소한도를 약속하자. 서브클래스를 사용하는 사용자는 차이점을 모르더라도
기반 클래스 인터페이스를 통해 사용할 수 있어야 한다.(리스코프 대체 원칙)

리스코프 대체 원칙, 부모 클래스의 인스턴스 자리에 자식 클래스의 인스턴스도 들어갈
수 있어야 한다. 부모 클래스의 행동 규약을 벗어나는 자식 클래스의 오버라이딩은 이를
위반한다.

## 22. 죽은 프로그램은 거짓말을 하지 않는다.

_일찍 작동을 멈추게 하라_

'그런 일은 절대 일어날 리 없어' 라는 사고에 빠지기 쉽다. 하지만 모든 에러는
정보를 주며 불가능하다고 생각한 뭔가가 발생하면, 그 프로그램은 더 이상 유효하지
않고, 그 시점 이후로 동작하는 모든 일은 수상쩍은 일이므로 가능한 한 프로그램이 
더 일찍 멈출 수 있도록 해야 한다.

## 23. 단정적 프로그래밍

_단정문을 사용해서 불가능한 상황을 예방하라_

'그건 절대 일어나지 않을거야' 라는 생각이 든다면, 단정문을 통해 그것을 증명할 수
있는 코드를 작성하자.

## 24. 언제 예외를 사용할까

무엇이 예외이고, 무엇이 에러인가......

_예외는 예외적인 문제에 사용하라_

가령, 코드가 어떤 파일을 읽으려 할 때 그 파일이 없는 경우, 파일이 반드시 있어야
하는 경우라면 '예외'를 발생시켜 실행 흐름상 오류에 대응하는 방법을 제시하자.
하지만, 파일이 반드시 있어야 하는 경우가 아니라면 '에러'를 발생시킨다.

## 25. 리소스 사용의 균형

_시작한 것은 끝내라_

단순히 리소스를 할당한 루틴이나 객체가 리소스를 해제하는 책임을 져야 한다는 의미가
아니라, 리소스를 할당하는 루틴이 해제 역시 책임져야 한다는 의미이다.

- 중첩할당, 리소스를 할당한 순서의 반대로 해제하고 동일한 리소스 집합을 여러곳에서
할당하는 경우, 할당 순서를 같게 하자.
- 객체와 예외, 할당과 해제의 균형은 클래스의 생성자와 소멸자를 생각나게 한다.
- 균형과 예외, 예외를 지원하는 언어는 리소스 해제에 복잡한 문제가 있을 수 있다.
가비지콜렉션을 사용하여 게으르게 자동으로 객체를 자동 삭제할 수 있으며, try,
finally 절이 있다면, try에서 실행된 코드 문장들을 finally 절 안에서 리소스
사용의 균형을 잡아야 한다.
- 균형을 점검하기, 리소스 해제 이후 적절하게 실제로 해제되었는지 점검하는 코드를
작성하는 것이 좋다.
- 









